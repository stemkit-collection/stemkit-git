# vim: ft=sh: sw=2:

# To use this library, please add the following line at the top of your
# shell script file:
#       . `type "${0}" | awk '{print $(NF)}' | xargs dirname`/gfb.sh.lib
#
# And this line at a very end:
#       main "${@}"

# @expects
#   main "${@}" => exit code
#   process_option <option> [ <argument> ] => 0, 2, 3, 4 (see declaration)
#   process_parameters "${@}" => 0: success, otherwise exits with error
#   options_usage => ?: ignored, echo string to stdout
#
# @provides
#   parse_command_line "${@}"
#   process_standard_option <option> [ <argument> ]
#   standard_options_usage
#   usage_and_exit <exit-code> [ <error-message> ]
#
#   report_simulation_mode
#   ensure_simulation_mode
#   is_simulation_mode
#   enable_simulation_mode
#   disable_simulation_mode
#
#   run <command-line>
#   indent_output_from <command-line>
#
#   log <level-label> <message>
#   error <message>
#   warning <message>
#   info <message>
#   details <message>
#   debug <message>
#   output <descriptor> <message>
#
#   contains_item <item> [ <string> ... ]

standard_options_usage () {
  echo '[-x][--help|-h][--force|-f][--dry-run|-n][--quiet|-q][--vebose|-v]'
}

# @returns
#   0: single option -> shift and go on
#   2: explicit end of options (--) -> shift and stop
#   3: implicit end of options -> stop withoug shift
#   4: option with argument -> shift twice and go on
#   *: error -> report and exit with failure
#
process_standard_option () {
  option=${1}
  argument=${2}

  case "${option}" in
    --force | -f )
      disable_simulation_mode
    ;;

    --dry-run | -n )
      enable_simulation_mode
    ;;

    --quiet | -q )
      exec 1>&5 2>&1
    ;;

    --verbose | -v )
      VERBOSE=yes
    ;;

    --help | -h )
      usage_and_exit 0
    ;;

    -x)
      set -xv
    ;;

    -- )
      return 2
    ;;

    --*=* )
      process_option `echo "${option}" | sed 's/=/ /'` || true
    ;;

    -? | --* )
      usage_and_exit 3 "Unsupported option: ${option}"
    ;;

    -* )
      parse_command_line `echo "${option}" | sed 's/-//g;s/./-& /g'`
    ;;

    *)
      return 3
    ;;
  esac
}

parse_command_line () {
  while [ ${#} -ne 0 ]; do
    process_option "${1}" "${2}" && shift && continue

    case ${?} in
      2)
        shift && break
      ;;

      3)
        break
      ;;

      4)
        shift && [ ${#} -ne 0 ] && shift
      ;;

      *)
        error 'Internal problem'
        exit 5
      ;;

    esac
  done

  process_parameters "${@}" || usage_and_exit 2 "Superfluous parameters: ${*}"
}

report_simulation_mode () {
  [ "${FORCE}" = yes ] || info "Simulation mode (dry-run), use --force for normal run"
}

ensure_simulation_mode () {
  [ "${FORCE}" = yes ] && {
    info "Switching to simulation mode (dry-run)"
    unset FORCE
  }
}

is_simulation_mode () {
  test "${FORCE}" != yes
}

enable_simulation_mode () {
  unset FORCE
}

disable_simulation_mode () {
  FORCE=yes
}

usage_and_exit () {
  [ "${2:+set}" = set ] && error "${2}"

  usage "`options_usage`"
  exit "${1}"
}

run () {
  marker="${FORCE:+==}"
  output 2 "${marker:-##} ${@}"

  [ "${FORCE}" = yes ] || return 0
  "${@}"
}

indent_output_from () {
  "${@}" 2>&1 | sed 's/^/    /'
}

info () {
  log INFO "${@}"
}

warning () {
  log WARNING "${@}"
}

error () {
  log ERROR "${@}"
}

details () {
  [ "${VERBOSE}" = yes ] && log DETAILS "${@}"
}

debug () {
  [ "${DEBUG}" = yes ] && log DEBUG "${@}"
}

log () {
  label=${1}
  shift

  output 2 "## ${script_name}: ${label}: ${@}"
}

usage () {
  output 2 "USAGE: ${script_name} ${@}"
}

output () {
  descriptor=${1}
  shift

  echo "${@}" 1>&"${descriptor}"
}

contains_item() {
  item=${1}
  shift

  for element in "${@}"; do
    [ "${element}" = "${item}" ] && return 0
  done

  return 1
}

exec 5>/dev/null
script_name=`basename "${0}"`

FORCE=no
DEBUG=no
QUIET=no
VERBOSE=no

contains_item "${script_name}" ${TRACE} && {
  DEBUG=yes
}
