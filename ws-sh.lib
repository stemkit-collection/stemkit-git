# vim: ft=sh: sw=2:

report_simulation_mode () {
  [ "${FORCE}" = yes ] || info "Simulation mode (dry-run), use --force for normal run"
}

ensure_simulation_mode () {
  [ "${FORCE}" = yes ] && {
    info "Switching to simulation mode (dry-run)"
    unset FORCE
  }
}

is_simulation_mode () {
  test "${FORCE}" != yes
}

enable_simulation_mode () {
  unset FORCE
}

disable_simulation_mode () {
  FORCE=yes
}

parse_command_line () {
  while [ ${#} -ne 0 ]; do
    process_option "${1}" "${2}" && shift && continue

    case ${?} in
      2)
        shift && break
      ;;

      3)
        break
      ;;

      4)
        shift && [ ${#} -ne 0 ] && shift
      ;;

      *)
        error 'Internal problem'
        exit 5
      ;;

    esac
  done

  process_parameters "${@}" || usage_and_exit 2 "Superfluous parameters: ${*}"
}

# @return
#   0: single option -> shift and go on
#   2: explicit end of options (--) -> shift and stop
#   3: implicit end of options -> stop withoug shift
#   4: option with argument -> shift twice and go on
#   *: error -> report and exit
#
process_standard_option () {
  option=${1}
  argument=${2}

  case "${option}" in
    --force | -f )
      FORCE=yes
    ;;

    --dry-run | -n )
      unset FORCE
    ;;

    --help | -h )
      usage_and_exit 0
    ;;

    -- )
      return 2
    ;;

    --*=* )
      process_option `echo "${option}" | sed 's/=/ /'` || true
    ;;

    -? | --* )
      usage_and_exit 3 "Unsupported option: ${option}"
    ;;

    -* )
      parse_command_line `echo "${option}" | sed 's/-//g;s/./-& /g'`
    ;;

    *)
      return 3
    ;;
  esac
}

standard_options_usage () {
  echo '[--help | -h][--force | -f][--dry-run | -n]'
}

usage_and_exit () {
  [ "${2:+set}" = set ] && error "${2}"

  usage "`options_usage`"
  exit "${1}"
}

run () {
  _marker="${FORCE:+==}"
  echo "${_marker:-##} ${@}" 1>&2

  [ "${FORCE}" = yes ] || return 0
  "${@}"
}

indent_output_from () {
  "${@}" 2>&1 | sed 's/^/    /'
}

info () {
  log INFO "${@}"
}

warning () {
  log WARNING "${@}"
}

error () {
  log ERROR "${@}"
}

debug () {
  [ "${DEBUG}" = yes ] && log DEBUG "${@}"
}

log () {
  label=${1}
  shift

  echo "## ${script_name}: ${label}: ${@}" 1>&2
}

usage () {
  echo "USAGE: ${script_name} ${@}" 1>&2
}

contains_item() {
  item=${1}
  shift

  for element in "${@}"; do
    [ "${element}" = "${item}" ] && return 0
  done

  return 1
}

exec 5>/dev/null
script_name=`basename "${0}"`

FORCE=no
DEBUG=no

contains_item "${script_name}" ${TRACE} && {
  DEBUG=yes
}

main "${@}"
