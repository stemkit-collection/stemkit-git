#!/bin/sh
# vim: ft=sh: sw=2:

unset REMOTE
unset FORCE
unset PUSH

main () {
  parse_command_line "${@}"

  root=`git ws 2>&5` || {
    error "Not a git workspace: `pwd`"
    exit 2
  }

  [ "${REMOTE}" = yes ] && {
    run git remote update --prune

    [ "${FORCE:+set}" = set ] && {
      info "Switching to simulation mode"
      unset FORCE
    }
  }

  git -C "${root}" tt top 2>&5 | while read top; do
    cd "${top}" && {
      set -- `git bbs | awk '$1 == "*" {print $(2), $(NF)}'`

      [ "${#}" -eq 2 ] || continue

      if [ "${PUSH:+set}" = set ]; then
        ensure_no_local_changes || pwd_and_run_indenting push "${?}" "${@}"
      else
        ensure_no_remote_changes || pwd_and_run_indenting merge_if_clean "${?}" "${@}"
      fi
    }
  done
}

pwd_and_run_indenting () {
  pwd && "${@}" 2>&1 | sed 's/^/  /'
}

parse_command_line () {
  for option in "${@}"; do
    case "${option}" in
      --force | -f )
        FORCE='=='
      ;;

      --remote | -r )
        REMOTE=yes
      ;;

      --push | -p )
        PUSH=yes
      ;;

      --help | -h )
        usage_and_exit 0
      ;;

      *)
        usage_and_exit 3 "Unsupported parameter: ${option}"
      ;;
    esac
  done

  [ "${FORCE:+set}" = set ] || info "Simulation mode (dry-run), use --force for normal run"
}

usage_and_exit () {
  [ "${2:+set}" = set ] && error "${2}"

  usage "[--help | -h] [--force | -f] [--remote | -r]"
  exit "${1}"
}

ensure_no_remote_changes () {
  return `git log --oneline ..@{u} | head -100 | wc -l`
}

ensure_no_local_changes () {
  return `git log --oneline @{u}.. | head -100 | wc -l`
}

merge_if_clean () {
  info "${2} <=[${1}] ${3}"

  changes=`git ss 2>&1 | tee /dev/stderr`
  [ "${changes:+set}" = set ] && {
    warning "Changes or untracked detected, not merging."
    return 2
  }

  run git merge --ff-only
}

push () {
  info "${2} [${1}]=> ${3}"
  run git push
}

run () {
  echo "${FORCE:-##} ${@}"

  [ "${FORCE:+set}" = set ] || {
    return 0
  }

  "${@}"
}

info () {
  log INFO "${@}"
}

warning () {
  log WARNING "${@}"
}

error () {
  log ERROR "${@}"
}

log () {
  label=${1}
  shift

  echo "## ${script_name}: ${label}: ${@}" 1>&2
}

usage () {
  echo "USAGE: ${script_name} ${@}" 1>&2
}

exec 5>/dev/null
script_name=`basename "${0}"`

main "${@}"
