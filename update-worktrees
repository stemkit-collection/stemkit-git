#!/bin/sh
# vim: ft=sh: sw=2:

unset REMOTE
unset FORCE
unset MERGE
unset PUSH

main () {
  parse_command_line "${@}"

  root=`git ws 2>&5` || {
    error "Not a git workspace: `pwd`"
    exit 2
  }

  [ "${REMOTE}" = yes ] && {
    run git remote update --prune

    [ "${FORCE}" = yes ] && {
      info "Switching to simulation mode (dry-run)"
      unset FORCE
    }
  }

  [ "${FORCE}" = yes ] || {
    MERGE=yes
    PUSH=yes
  }

  git -C "${root}" tt top 2>&5 | while read top; do
    cd "${top}" && {
      set -- `git bbs | awk '$1 == "*" {print $(2), $(NF)}'`

      [ "${#}" -eq 2 ] || continue

      pwd="pwd"
      [ "${PUSH}" = yes ] && {
        ensure_no_local_changes || {
          number=${?}
          "${pwd}"

          indent_output_from push "${number}" "${@}"
          pwd="true"
        }
      }

      [ "${MERGE}" = yes ] && {
        ensure_no_remote_changes || {
          number=${?}
          "${pwd}"

          indent_output_from merge_if_clean "${number}" "${@}"
          pwd="true"
        }
      }
    }
  done
}

parse_command_line () {
  MERGE=yes

  for option in "${@}"; do
    case "${option}" in
      --force | -f )
        FORCE=yes
      ;;

      --dry-run | -n )
        unset FORCE
      ;;

      --remote | -r )
        REMOTE=yes
        FORCE=yes
      ;;

      --push | -p )
        PUSH=yes
        unset MERGE
      ;;

      --merge | -m )
        MERGE=yes
      ;;

      --help | -h )
        usage_and_exit 0
      ;;

      *)
        usage_and_exit 3 "Unsupported parameter: ${option}"
      ;;
    esac
  done

  [ "${FORCE}" = yes ] || info "Simulation mode (dry-run), use --force for normal run"
}

usage_and_exit () {
  [ "${2:+set}" = set ] && error "${2}"

  usage "[--help | -h][--force | -f][--dry-run | -n][--remote | -r][--push | -p][--merge | -m]"
  exit "${1}"
}

ensure_no_remote_changes () {
  return `git log --oneline ..@{u} | head -100 | wc -l`
}

ensure_no_local_changes () {
  return `git log --oneline @{u}.. | head -100 | wc -l`
}

ensure_clean_workspace () {
  return `git -c color.status=always status -s 2>&1 | tee /dev/stderr | head -100 | wc -l`
}

merge_if_clean () {
  info "${2} <=[${1}] ${3}"

  ensure_clean_workspace || {
    warning "Detected ${?} changed or untracked, not merging."
    return 2
  }

  run git merge --ff-only
}

push () {
  info "${2} [${1}]=> ${3}"
  run git push
}

run () {
  _marker="${FORCE:+==}"
  echo "${_marker:-##} ${@}"

  [ "${FORCE}" = yes ] || return 0
  "${@}"
}

indent_output_from () {
  "${@}" 2>&1 | sed 's/^/    /'
}

info () {
  log INFO "${@}"
}

warning () {
  log WARNING "${@}"
}

error () {
  log ERROR "${@}"
}

log () {
  label=${1}
  shift

  echo "## ${script_name}: ${label}: ${@}" 1>&2
}

usage () {
  echo "USAGE: ${script_name} ${@}" 1>&2
}

exec 5>/dev/null
script_name=`basename "${0}"`

main "${@}"
