#!/bin/sh
# vim: ft=sh: sw=2:

unset REMOTE
unset FORCE
unset PUSH

MERGE=yes

main () {
  parse_command_line "${@}"

  root=`git ws 2>&5` || {
    error "Not a git workspace: `pwd`"
    exit 2
  }

  [ "${FORCE}" = yes ] || info "Simulation mode (dry-run), use --force for normal run"

  [ "${REMOTE}" = yes ] && {
    run git remote update --prune

    [ "${FORCE}" = yes ] && {
      info "Switching to simulation mode (dry-run)"
      unset FORCE
    }
  }

  [ "${FORCE}" = yes ] || {
    MERGE=yes
    PUSH=yes
  }

  git -C "${root}" tt top 2>&5 | while read top; do
    cd "${top}" && {
      set -- `git bbs | awk '$1 == "*" {print $(2), $(NF)}'`

      [ "${#}" -eq 2 ] || continue

      pwd="pwd"
      [ "${PUSH}" = yes ] && {
        ensure_no_local_changes || {
          number=${?}
          "${pwd}"

          indent_output_from push "${number}" "${@}"
          pwd="true"
        }
      }

      [ "${MERGE}" = yes ] && {
        ensure_no_remote_changes || {
          number=${?}
          "${pwd}"

          indent_output_from merge_if_clean "${number}" "${@}"
          pwd="true"
        }
      }
    }
  done
}

parse_command_line () {
  while [ ${#} -ne 0 ]; do
    process_option "${1}" "${2}" || {
      case ${?} in
        1) shift; break ;;
        2) break ;;
        3) shift ;;
      esac
      [ ${#} -eq 0 ] && break
    }
    shift
  done

  [ "${#}" -ne 0 ] && usage_and_exit 2 "Too many parameters: ${*}"
}

process_option () {
  case "${1}" in
    --force | -f )
      FORCE=yes
    ;;

    --dry-run | -n )
      unset FORCE
    ;;

    --remote | -r )
      REMOTE=yes
      FORCE=yes
    ;;

    --push | -p )
      PUSH=yes
      unset MERGE
    ;;

    --merge | -m )
      MERGE=yes
    ;;

    --help | -h )
      usage_and_exit 0
    ;;

    -- )
      return 1
    ;;

    -[fnrpmh]* )
      set -- `echo "${1}" | sed 's/-//g;s/./-& /g'`
      parse_command_line "${@}"
    ;;

    -*)
      usage_and_exit 3 "Unsupported option: ${1}"
    ;;

    *)
      return 2
    ;;
  esac

  return 0
}

usage_and_exit () {
  [ "${2:+set}" = set ] && error "${2}"

  usage "[--help | -h][--force | -f][--dry-run | -n][--remote | -r][--push | -p][--merge | -m]"
  exit "${1}"
}

ensure_no_remote_changes () {
  return `git log --oneline ..@{u} | head -100 | wc -l`
}

ensure_no_local_changes () {
  return `git log --oneline @{u}.. | head -100 | wc -l`
}

ensure_clean_workspace () {
  return `git -c color.status=always status -s 2>&1 | tee /dev/stderr | head -100 | wc -l`
}

merge_if_clean () {
  info "${2} <=[${1}] ${3}"

  ensure_clean_workspace || {
    warning "Detected ${?} changed or untracked, not merging."
    return 2
  }

  run git merge --ff-only
}

push () {
  info "${2} [${1}]=> ${3}"
  run git push
}

run () {
  _marker="${FORCE:+==}"
  echo "${_marker:-##} ${@}"

  [ "${FORCE}" = yes ] || return 0
  "${@}"
}

indent_output_from () {
  "${@}" 2>&1 | sed 's/^/    /'
}

info () {
  log INFO "${@}"
}

warning () {
  log WARNING "${@}"
}

error () {
  log ERROR "${@}"
}

log () {
  label=${1}
  shift

  echo "## ${script_name}: ${label}: ${@}" 1>&2
}

usage () {
  echo "USAGE: ${script_name} ${@}" 1>&2
}

exec 5>/dev/null
script_name=`basename "${0}"`

main "${@}"
